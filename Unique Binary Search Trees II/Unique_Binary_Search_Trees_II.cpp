/******************************************Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.For example,Given n = 3, your program should return all 5 unique BST's shown below.   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3*****************************************/typedef unsigned int uint;struct TreeNode {	int val;	TreeNode *left;	TreeNode *right;	TreeNode(int x) : val(x), left(NULL), right(NULL) {}};class Solution {public:	std::vector<TreeNode*> generateTrees(int n)	{		std::vector<int> treeVec;		for (int i = 0; i < n; ++i) {			treeVec.push_back(i+1);		}		if (treeVec.empty()) {			std::vector<TreeNode*> tmp;			tmp.push_back(0);			return tmp;		}		return mergeTree(treeVec, 0, treeVec.size()-1);	}		std::vector<TreeNode*> mergeTree(const vector<int>& treeVec, int i, int j) 	{		if (i > j) return std::vector<TreeNode*> ();		if (i == j) {			TreeNode* pNode = new TreeNode(treeVec[i]);			std::vector<TreeNode*> tmp;			tmp.push_back(pNode);			return tmp;		}		std::vector<TreeNode*> allTrees;		for (uint k = i; k <= j; ++k) {			std::vector<TreeNode*> left = mergeTree(treeVec, i, k-1);			std::vector<TreeNode*> right = mergeTree(treeVec, k+1, j);						if (left.size()) {				for (uint pos_l = 0; pos_l < left.size(); ++pos_l) {					if (right.size()) {						for (uint pos_r = 0; pos_r < right.size(); ++pos_r) {							TreeNode* pRoot = new TreeNode(treeVec[k]);							pRoot->left = left[pos_l];							pRoot->right = right[pos_r];							allTrees.push_back(pRoot);						}					} else {						TreeNode* pRoot = new TreeNode(treeVec[k]);						pRoot->left = left[pos_l];						allTrees.push_back(pRoot);					}									}			} else {				for (uint pos_r = 0; pos_r < right.size(); ++pos_r) {					TreeNode* pRoot = new TreeNode(treeVec[k]);					pRoot->right = right[pos_r];					allTrees.push_back(pRoot);				}			}					} 		return allTrees;	}};