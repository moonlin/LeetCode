/**************************************** Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.For example,Given:s1 = "aabcc",s2 = "dbbca",When s3 = "aadbbcbcac", return true.When s3 = "aadbbbaccc", return false.****************************************/// Recursive, Time Limit Exceededclass Solution {public:    bool isInterleave(std::string s1, std::string s2, std::string s3)	{		return this->isInterleave_impl(s1, s2, s3);	}	bool isInterleave_impl(std::string& s1, std::string& s2, std::string& s3)	{		if (s3.size() == 0) return true;		if (s1.size() + s2.size() != s3.size()) return false;		if (s3.size() == 1) {			if (s1.size()) return s1[0] == s3[0];			if (s2.size()) return s2[0] == s3[0];		}		uint i, j, k;		i = j = k = 0;		while (k < s3.size()) {			while (i < s1.size() && k < s3.size() &&   	\					s3[k] == s1[i] && (j == s2.size() || s3[k] != s2[j])) {				++k; 				++i;			}			while (j < s2.size() && k < s3.size() &&	\					s3[k] == s2[j] && (i == s1.size() || s3[k] != s1[i])) {				++k; 				++j;			}			if (i == s1.size()) {				while (j < s2.size() && s2[j] == s3[k]) {					++j; ++k;				}				if (j < s2.size()) return false;			}			if (j == s2.size()) {				while (i < s1.size() && s1[i] == s3[k]) {					++i; ++k;				}				if (i < s1.size()) return false;			}			if (k == s3.size()) return true;			if (s3[k] != s1[i] && s3[k] != s2[j]) return false;			if (s3[k] == s1[i] && s3[k] == s2[j]) {				if (isInterleave(s1.substr(i+1), s2.substr(j), s3.substr(k+1))) {					return true;				}				return isInterleave(s1.substr(i), s2.substr(j+1), s3.substr(k+1));			}		}	}	};int main(){		Solution solve;	std::string s1 ("aa");	std::string s2 ("ab");	std::string s3 ("aaba");	bool ret = solve.isInterleave(s1, s2, s3);	getchar();	return 0;}