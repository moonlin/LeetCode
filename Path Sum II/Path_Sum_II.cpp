/***********************************Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.For example:Given the below binary tree and sum = 22,              5             / \            4   8           /   / \          11  13  4         /  \    / \        7    2  5   1return[   [5,4,11,2],   [5,8,4,5]]***********************************/#include <iostream>#include <vector>#include <string>#include <queue>#include <map>#include <stack>using namespace std;typedef unsigned int uint;struct TreeNode {	int val;	TreeNode *left;	TreeNode *right;	TreeNode(int x) : val(x), left(NULL), right(NULL) {}};class Solution {public:	vector<vector<int>> pathSum(TreeNode *pRoot, int sum)	{		paths.clear();		vector<int> treeNode;		dfs(pRoot, sum, treeNode);		return paths;	}	void dfs(TreeNode *pRoot, int sum, vector<int>& treeNode)	{		if (pRoot == 0) return;		treeNode.push_back(pRoot->val);		if (pRoot->left == 0 && pRoot->right == 0) {			if (pRoot->val == sum) {				paths.push_back(treeNode);				treeNode.pop_back();				return;			}		}		dfs(pRoot->left, sum - pRoot->val, treeNode);		dfs(pRoot->right, sum - pRoot->val, treeNode);		treeNode.pop_back();	}	vector<vector<int>> paths;};