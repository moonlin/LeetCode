/***************************************** Reverse a linked list from position m to n. Do it in-place and in one-pass.For example:Given 1->2->3->4->5->NULL, m = 2 and n = 4,return 1->4->3->2->5->NULL.Note:Given m, n satisfy the following condition:1 <= m <= n <= length of list.*****************************************/#include <vector>#include <string>#include <queue>#include <map>#include <stack>typedef unsigned int uint;struct ListNode {	int val;	ListNode *next;	ListNode(int x) : val(x), next(NULL) {}}; class Solution {public:	ListNode* reverseBetween(ListNode* head, int m, int n)	{		ListNode* pre = 0;		ListNode* p = head;		int i = 1;		while (i < m && p) { 			pre = p;			p = p->next;			++i;									// here we use ++i not while (i++ < m...)		}		ListNode* pEnd = p;		ListNode* pPre = 0;		while (i++ < n && p) { 					   // here we use while (i++ < n...), it is different between above.			ListNode* pNext = p->next;			p->next = pPre;			pPre = p;			p = pNext;		}		ListNode* pTail = p->next;		p->next = pPre;		if (pre) {			pre->next = p;		} else {			head = p;		}		pEnd->next = pTail;		return head;	}	};int main(){		ListNode* l1 = new ListNode(-1);	ListNode* l2 = new ListNode(-3);	ListNode* l3 = new ListNode(3);	l1->next = l2;	//l2->next = l3;	Solution solve;	ListNode* ret = solve.reverseBetween(l1, 1, 2);	getchar();	return 0;}