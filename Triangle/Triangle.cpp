/***********************************Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.For example, given the following triangle[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.***********************************/class Solution {public:	int minimumTotal(std::vector<std::vector<int>>& triangle)	{		if (triangle.empty()) return 0;		if (triangle[0].empty()) return 0;		std::vector<int> dp;		dp.push_back(triangle[0][0]);		for (uint i = 1; i < triangle.size(); ++i) {			dp.resize(dp.size()+1);			for (int j = dp.size()-1; j >= 0; --j) {				if (j == dp.size()-1) dp[j] = dp[j-1] + triangle[i][j];				else if (j == 0) dp[j] = dp[j] + triangle[i][j];				else {					dp[j] = std::min(dp[j], dp[j-1]) + triangle[i][j];				}			}		}		int gmin = INT_MAX;		for (uint i = 0; i < dp.size(); ++i) {			gmin = std::min(gmin, dp[i]);		}		return gmin;	}};