/***********************************Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.For example, given the following triangle[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.***********************************/#include <iostream>#include <vector>#include <string>#include <fstream>#include <queue>#include <map>using namespace std;typedef unsigned int uint;class Solution {public:	int minimumTotal(vector<vector<int> > &triangle)	{		return dp(triangle);	}	int dp(const vector<vector<int> >& triangle) 	{		if (triangle.empty()) return 0;		vector<int> level;		level.push_back(triangle[0][0]);		for (int i = 1; i < triangle.size(); ++i) {			vector<int> tmp;			tmp.resize(level.size()+1);			tmp[0] = level[0] + triangle[i][0];			tmp[level.size()] = level[level.size()-1] + triangle[i][level.size()];			for (int j = 1; j < triangle[i].size()-1; ++j) {				tmp[j] = std::min(level[j-1], level[j]) + triangle[i][j];				}			level.swap(tmp);		}		int min = INT_MAX;		for (uint i = 0; i < level.size(); ++i) {			min = std::min(min, level[i]);		}		return min;	}};int main(){		vector<int> a1;	a1.push_back(-1);	vector<int> a2;	a2.push_back(3);	a2.push_back(2);		vector<int> a3;	a3.push_back(-3);	a3.push_back(1);	a3.push_back(-1);	vector<int> a4;	a4.push_back(4);	a4.push_back(1);	a4.push_back(8);	a4.push_back(3);	vector<vector<int>> b;	b.push_back(a1);	b.push_back(a2);	b.push_back(a3);	b.push_back(a4);	Solution solve;	int ret = solve.minimumTotal(b);	std::cout <<"ret == " <<ret <<'\n';	getchar();	return 0;}