/***************************************Follow up for problem "Populating Next Right Pointers in Each Node".What if the given tree could be any binary tree? Would your previous solution still work?Note:    You may only use constant extra space.For example,Given the following binary tree,         1       /  \      2    3     / \    \    4   5    7After calling your function, the tree should look like:         1 -> NULL       /  \      2 -> 3 -> NULL     / \    \    4-> 5 -> 7 -> NULL***************************************/#include <iostream>#include <vector>#include <string>#include <queue>#include <map>#include <stack>using namespace std;typedef unsigned int uint;struct TreeLinkNode {	int val;	TreeLinkNode *left, *right, *next;	TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}};class Solution {public:    void connect(TreeLinkNode *root)	{		traverse(root);	}	void traverse(TreeLinkNode* p)	{		if (p == 0) return;		TreeLinkNode* pNext = p->next;		TreeLinkNode* pNeighbour = 0;		while (pNext) {			if (pNext->left) {				pNeighbour = pNext->left;				break;			}			if (pNext->right) {				pNeighbour = pNext->right;				break;			}			pNext = pNext->next; 		}		if (p->left) {			p->left->next = p->right? p->right: pNeighbour;		}		if (p->right) {			p->right->next = pNeighbour;		}		traverse(p->right);		traverse(p->left);	}};